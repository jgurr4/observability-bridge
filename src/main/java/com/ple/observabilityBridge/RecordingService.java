/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.ple.observabilityBridge;

import com.ple.util.*;

import java.util.Arrays;

/**
 * RecordingService is the class used to start the process of logging/traces/metrics.
 * Basically you pass in the custom AdapterContext and RecordingHandler classes into this class based on
 * your observability needs. Then you should call recordingService.log() methods as needed to perform the
 * monitoring actions within a particular method.
 * Should only be used by a single thread. If it is needed in another thread, pass a cloned instance.
 *
 * To create another instance of RecordingService you must use the clone() method since this object is immutable.
 *
 * For now there is only a locally scoped version of RecordingService. However, for automatic scope switching and
 * certain high-level API operations we may include a Global RecordingService Class.
 */
@Immutable
public class RecordingService {

  public static final RecordingService empty = make(IHashMap.empty);
  public final IMap<String, RecordingHandler> handlers;

  private RecordingService(IMap<String, RecordingHandler> handlers) {
    this.handlers = handlers;
  }

  public static RecordingService make(IMap<String, RecordingHandler> handlers) {
    return new RecordingService(handlers);
  }

  public static RecordingService make(String name, RecordingHandler handler) {
    return new RecordingService(IHashMap.make(name, handler));
  }

  public ObservabilityContext open(ObservabilityContext contextMap, String group, IMap<String, String> dimensions) {
    for (RecordingHandler handler : handlers.values()) {
      final String name = "generatedname";
      final HandlerContext handlerContext = handler.open(contextMap.get(handler), group, name, dimensions);
      contextMap = contextMap.put(handler, handlerContext);
    }
    return contextMap;
  }

  public ObservabilityContext open(ObservabilityContext context, String group, String... dimensions) {
    return open(context, group, IArrayMap.make(Arrays.asList(dimensions)));
  }

  public ObservabilityContext open(ObservabilityContext context, String group, String name, IMap<String, String> dimensions) {
    for (RecordingHandler handler : handlers.values()) {
      handler.open(context.get(handler), group, name, dimensions);
    }
    return open(context, group, IArrayMap.empty);
  }

  public ObservabilityContext close(ObservabilityContext context, String group, IMap<String, String> dimensions) {
    for (RecordingHandler handler : handlers.values()) {
      final HandlerContext handlerContext = handler.close(context.get(handler), group, dimensions);
      context = context.put(handler, handlerContext);
    }
    return context;
  }

  public ObservabilityContext close(ObservabilityContext context, String group, Object... dimensions) {
    return close(context, group, IArrayMap.make(dimensions));
  }

  public ObservabilityContext close(ObservabilityContext context, String group) {
    return close(context, group, IArrayMap.empty);
  }

  public ObservabilityContext log(ObservabilityContext context, String group, int importance,
                                  IMap<String, String> dimensions) {
    for (RecordingHandler handler : handlers.values()) {
      final HandlerContext handlerContext = handler.log(context.get(handler), group, dimensions, importance);
      context = context.put(handler, handlerContext);
    }
    return context;
  }

  public ObservabilityContext log(ObservabilityContext context, String group, int importance, String... dimensions) {
    return log(context, group, importance, IArrayMap.make(Arrays.asList(dimensions)));
  }

  public ObservabilityContext log(ObservabilityContext context, String group, String... dimensions) {
    return log(context, group, 0, IArrayMap.make(dimensions));
  }

  public RecordingService clone() {
    return new RecordingService(handlers);
  }

}
